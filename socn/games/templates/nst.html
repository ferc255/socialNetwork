<html>
  <head>
    <style>
      *
      {
        margin: 0;
        padding: 0;
      }
      
      .header-p
      {
        text-align: center;
        
        font-size: 40px;
        
        
      }
      .header-a
      {
        color: #ffaa00;
        text-decoration: none;
      }
      
      .header-div
      {
        background-color: black;
        padding: 0;
        margin:0;
      }

      
      
      .navbar-a
      {      
        //margin: 10px;
        color: black;
        display: block;
        text-decoration: none;
        padding: 10px 20px;
      }

      .navbar-a:hover
      {
        background-color: #FF4400;
        color: white;
      }
      
      .navbar-ul
      {
        overflow: hidden;        
        list-style-type: none;
        //background-color: blue;
      }

      .middle
      {
        overflow: hidden;
        margin-top: 10px;
        //background-color: #CCCCCC;
      }

      .middle-left
      {
        width: 200px;
        float: left;
        //background-color: green;
      }

      .my-navbar
      {
        
        background-color: #ffaa00;
        
        border-radius: 0px 10px 10px 0px;
        
        
        
      }
      
      .middle-right
      {
        float: left;
        width: calc(100% - 300px);
        //padding-top: 0;
        margin-left: 20px;
        padding-left: 10px;
        padding-right: 20px;
        //background-color: brown;
        //display: table-cell;
      }

      .body
      {
        margin: 0px;
        background-color: blue;
        
      }

      html
      {
      height: 100%;
      }
      .footer
      {
        padding: 40px;
        box-sizing: border-box;
        position: absolute;
        bottom: 0;
        left: 0;
        right: 0;
        height: 90px;
        margin-top: 20px;
        //border-radius: 5px;
        text-align: center;
        background-color: #ff4400;//grey;
      }

      //.dropdown:hover .dropdown-content
      //{
       // display: block;
      
      //}

      .dropdown
      {
        display:inline-block;
        position: relative;
        width: 100%
      }

      .dropbtn
      {
        cursor: pointer;
      }

      .dropdown-content
      {
        display: none;
        box-shadow: 0px 8px 16px 0px rgba(F, F, F, 5);
        z-index: 1;
      
        background-color: #FF4400;
        position: absolute;
      //left: 90%;
      width: 200px;
      }
      
      .dropdown-content2
      {
        display: block;
        box-shadow: 0px 8px 16px 0px rgba(F, F, F, 5);
        z-index: 1;
      
        background-color: #FF4400;
        position: absolute;
      //left: 90%;
      width: 200px;
      }
      
      .navbar-b
      {      
        //margin: 10px;
        color: black;
        display: block;
        text-decoration: none;
        padding: 10px 20px;
      }
      .navbar-c
      {      
        //margin: 10px;
        color: green;
        display: block;
        text-decoration: none;
        padding: 10px 20px;
      }

    </style>

    <meta charset="utf-8">
  </head>
  <body>
  
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.1/jquery.min.js"></script>
<script>
/*$(document).ready(function() {
  $('.navbar-b').click(function() {
    $('.dropdown-content').toggleClass('dropdown-content2');
  });
}); */

function myfunc(x)
{
	//var y = document.getElementById("lah");
    //alert(y.nextSibling.className);
	//alert(x.nextSibling.innerHTML);
	//$(x).parent().next().toggleClass('dropdown-content2');
    //alert('j');
    
    //x.className = 'navbar-c';
    var nextElem = x.nextElementSibling;
    if (nextElem.className == 'dropdown-content')
        nextElem.className = 'dropdown-content2';
    else
        nextElem.className = 'dropdown-content';
    //var y = $(x).nextElementSibling.className;
    //alert(y);
}
</script>
    
    <div class="header-div">
      <p class="header-p"><a class="header-a" href="#">A L E K S ' S</a><p>
    </div>
    <div class="middle">
      <div class="middle-left">
        <div class="my-navbar">
          <ul class="navbar-ul">
            <li><a class="navbar-a" href="#">Home</a></li>
            <li><a class="navbar-a" href="#">Home2</a></li>
            <li><a class="navbar-a" href="#">Home3</a></li>
            <div class="dropdown">
              <a class="navbar-b" onclick="myfunc(this)">kek <p style="float:right;" align="right">&dtrif;</p></a>

              <div class="dropdown-content">
                <li><a style="display: block;" class="navbar-a" href="#">link 1</a></li>
                <li><a style="display: block;" class="navbar-a" href="#">link 2</a></li>
              </div>
            </div>
            <br><br><br><br>
            <div class="dropdown">
              <a class="navbar-b" id="lah" onclick="myfunc(this)">kek &#8711;</a>

              <div class="dropdown-content">
                <li><a style="display: block;" class="navbar-a" href="#">link 1</a></li>
                <li><a style="display: block;" class="navbar-a" href="#">link 2</a></li>
              </div>
            </div>
            
            <br><br><br><br>
            <li><a class="navbar-a" href="#">Home3</a></li>
          </ul>
        </div>
        skldfj;
      </div>
        
      <div class="middle-right">
        
          suck

            Всем привет!

            Любители ли вы задачи, которые расчитаны на Ad Hoc решение? Я — терпеть не могу! Поэтому я решил сделать подборку идей, которые могут быть применены к достаточно большому классу задач. Добавляйте ещё, если о чём-то забыл. :)

            1. Слияние множеств за амортизированно. Если у нас есть некоторые множества, которые нам потом нужно будет соединять, поддерживая промежуточные результаты, то можно делать это в лоб, всегда добавляя меньшее множество к большему. Таким образом, каждый элемент будет перенесён в какое-то другое множество не более, чем раз, так как новое множество для него каждый раз будет увеличиваться хотя бы в два раза. На этом, в частности, основана одна из версий общеизвестного DSU. Из применений — можно сливать множества внутри обхода дерева в глубину и таким образом можно для каждой вершины в какой-то момент времени подержать в руках множество всех элементов её поддерева.

            2. Подвохи в задачах. Часть 1. Ни для кого не секрет, что иногда авторы пытаются скрыть важные детали условия. Так, я однажды встретил в разделе input ограничения . И сразу и не скажешь, что на самом деле .

            3. на подотрезках. Пусть у нас есть множество чисел, мы добавляем к нему элементы и после этого считаем всех чисел множества. Тогда мы получим не более значений для него. отсюда следует, что можно следующим образом поддерживать в сжатом виде информацию о на всех подотрезках массива :
            code

            4. От статичного множества к расширяемому за . Пусть для какого-то статичного множества мы умеем вычислять функцию, такую что , где — функция, которую мы также можем быстро вычислять. Например, — количество элементов множества, меньших , . Или — количество вхождений строк из в строку , — всё ещё операция суммы. 

            Пусть мы для некоторого множества умеем выполнять неамортизированную операцию добавления элемента и считать какие-то запросы. Тогда мы можем за дополнительный времени научиться также обрабатывать в оффлайне запросы удаления из множества. Давайте для каждого добавления элемента x множества сопоставим момент, в который этот элемент покинет множество. То есть, определим для каждого элемента отрезок времени , на протяжение которого элемент присутствует в множестве. Теперь введём рекурсивную процедуру, обрабатывающую отрезок времени с тем условием, что когда мы в неё входим, в множество уже добавлены все элементы, отрезки которых целиком покрывают . Далее, поддерживая этот инвариант, мы рекурсивно запускаемся в половинки отрезка. Наконец, когда мы доберёмся до базы, отрезка длины 1, мы сможем выполнить запрос так, будто перед нами готовое статичное множество. Об этой идее мне также поведал Burunduk1, о чём я написал отдельный пост (про dynamic connectivity). 
            
            
             2. Подвохи в задачах. Часть 1. Ни для кого не секрет, что иногда авторы пытаются скрыть важные детали условия. Так, я однажды встретил в разделе input ограничения . И сразу и не скажешь, что на самом деле .

            3. на подотрезках. Пусть у нас есть множество чисел, мы добавляем к нему элементы и после этого считаем всех чисел множества. Тогда мы получим не более значений для него. отсюда следует, что можно следующим образом поддерживать в сжатом виде информацию о на всех подотрезках массива :
            code

            4. От статичного множества к расширяемому за . Пусть для какого-то статичного множества мы умеем вычислять функцию, такую что , где — функция, которую мы также можем быстро вычислять. Например, — количество элементов множества, меньших , . Или — количество вхождений строк из в строку , — всё ещё операция суммы. 

            Пусть мы для некоторого множества умеем выполнять неамортизированную операцию добавления элемента и считать какие-то запросы. Тогда мы можем за дополнительный времени научиться также обрабатывать в оффлайне запросы удаления из множества. Давайте для каждого добавления элемента x множества сопоставим момент, в который этот элемент покинет множество. То есть, определим для каждого элемента отрезок времени , на протяжение которого элемент присутствует в множестве. Теперь введём рекурсивную процедуру, обрабатывающую отрезок времени с тем условием, что когда мы в неё входим, в множество уже добавлены все элементы, отрезки которых целиком покрывают . Далее, поддерживая этот инвариант, мы рекурсивно запускаемся в половинки отрезка. Наконец, когда мы доберёмся до базы, отрезка длины 1, мы сможем выполнить запрос так, будто перед нами готовое статичное множество. Об этой идее мне также поведал Burunduk1, о чём я написал отдельный пост (про dynamic connectivity). 
            
          
        
      </div>
      
    </div>
    <!--
    <div class="footer">
      <p> foot</p>
    </div>-->
   

    <!--
    <div class="wew">
      <div class="w">
        sldkf;
      </div>
      <div class="ww">
        lksdggggggggg

ества внутри обхода дерева в глубину и таким образом можно для каждой вершины в какой-то момент времени под\
        ержать в руках множество всех элементов её поддерева.

                    2. Подвохи в задачах. Часть 1. Ни для кого не секрет, что иногда авторы пытаются скрыть важные детали условия. Та\
        к, я однажды встретил в разделе input ограничения . И сразу и не скажешь, что на самом деле .

                    3. на подотрезках. Пусть у нас есть множество чисел, мы добавляем к нему элементы и после этого считаем всех чисе\
        л множества. Тогда мы получим не более значений для него. отсюда следует, что можно следующим образом поддерживать в сжатом в\
        иде информацию о на всех подотрезках массива :
                    code

                    4. От статичного множества к расширяемому за . Пусть для какого-то статичного множества мы умеем вычислять функци\
        ю, такую что , где — функция, которую мы также можем быстро вычислять. Например, — количество элементов множества, меньших , \
        . Или — количество вхождений строк из в строку , — всё ещё операция суммы.

                    Пусть мы для некоторого множества у

        
      </div>
    </div>
<div>
  lskdfj
  </div>
-->
    
  </body>
</html>
